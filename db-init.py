import os
from importlib.util import module_from_spec, spec_from_file_location

from db import get_connection, ensure_identities
from scoring import score_weeks


def load_module(module_name, filename):
    base_dir = os.path.dirname(__file__)
    module_path = os.path.join(base_dir, filename)
    spec = spec_from_file_location(module_name, module_path)
    module = module_from_spec(spec)
    spec.loader.exec_module(module)  # type: ignore[union-attr]
    return module


SCHEMA_SQL = """
CREATE TABLE IF NOT EXISTS leagues (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    year INTEGER NOT NULL,
    mlb_team TEXT
);

CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    email TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS teams (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    league_id INTEGER NOT NULL REFERENCES leagues(id),
    user_id INTEGER NOT NULL REFERENCES users(id),
    name TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS user_accounts (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'owner',
    team_id INTEGER REFERENCES teams(id),
    is_active INTEGER NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS players (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    mlb_id INTEGER UNIQUE NOT NULL,
    name TEXT NOT NULL,
    first_name TEXT,
    last_name TEXT,
    name_slug TEXT,
    position_code TEXT,
    position_name TEXT,
    position_type TEXT,
    bat_side TEXT,
    throw_side TEXT,
    jersey_number INTEGER,
    status TEXT,
    birth_date DATE,
    birth_city TEXT,
    birth_state TEXT,
    birth_country TEXT,
    height TEXT,
    weight INTEGER,
    is_active INTEGER DEFAULT 1,
    last_updated TIMESTAMP
);

CREATE TABLE IF NOT EXISTS team_player (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    team_id INTEGER NOT NULL REFERENCES teams(id),
    player_id INTEGER NOT NULL REFERENCES players(id),
    UNIQUE (team_id, player_id)
);

CREATE TABLE IF NOT EXISTS stats (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    player_id INTEGER NOT NULL REFERENCES players(id),
    team_id INTEGER NOT NULL REFERENCES teams(id),
    date TIMESTAMP NOT NULL,
    offense INTEGER,
    pitching INTEGER
);

CREATE TABLE IF NOT EXISTS points (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    team_id INTEGER NOT NULL REFERENCES teams(id),
    date TIMESTAMP NOT NULL,
    value INTEGER NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('offense', 'defense'))
);

CREATE TABLE IF NOT EXISTS roster_move_requests (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    team_id INTEGER NOT NULL REFERENCES teams(id),
    submitted TIMESTAMP NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending'
);

CREATE TABLE IF NOT EXISTS roster_move_request_players (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    roster_move_request_id INTEGER NOT NULL REFERENCES roster_move_requests(id),
    player_id INTEGER NOT NULL REFERENCES players(id),
    action TEXT NOT NULL CHECK (action IN ('add', 'drop')),
    UNIQUE (roster_move_request_id, player_id)
);

CREATE TABLE IF NOT EXISTS audit (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    datetime TIMESTAMP NOT NULL,
    league_id INTEGER,
    user_id INTEGER,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL,
    old_value TEXT,
    new_value TEXT,
    prev_hash TEXT,
    row_hash TEXT NOT NULL
);

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE INDEX IF NOT EXISTS idx_audit_datetime
    ON audit(datetime);
CREATE INDEX IF NOT EXISTS idx_audit_table_datetime
    ON audit(table_name, datetime);
CREATE INDEX IF NOT EXISTS idx_audit_league_datetime
    ON audit(league_id, datetime);
CREATE INDEX IF NOT EXISTS idx_user_accounts_email
    ON user_accounts(email);
CREATE INDEX IF NOT EXISTS idx_audit_user_datetime
    ON audit(user_id, datetime);
CREATE UNIQUE INDEX IF NOT EXISTS idx_audit_row_hash
    ON audit(row_hash);

CREATE OR REPLACE FUNCTION audit_no_update() RETURNS trigger AS $$
BEGIN
  RAISE EXCEPTION 'audit table is append-only';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION audit_no_delete() RETURNS trigger AS $$
BEGIN
  RAISE EXCEPTION 'audit table is append-only';
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_no_update ON audit;
DROP TRIGGER IF EXISTS audit_no_delete ON audit;

CREATE TRIGGER audit_no_update
BEFORE UPDATE ON audit
FOR EACH ROW EXECUTE FUNCTION audit_no_update();

CREATE TRIGGER audit_no_delete
BEFORE DELETE ON audit
FOR EACH ROW EXECUTE FUNCTION audit_no_delete();

CREATE OR REPLACE FUNCTION audit_insert_player() RETURNS trigger AS $$
BEGIN
  INSERT INTO audit (datetime, user_id, table_name, operation, new_value, prev_hash, row_hash)
  VALUES (
    CURRENT_TIMESTAMP,
    COALESCE(current_setting('app.user_id', true), '0')::int,
    'players',
    'INSERT',
    json_build_object('id', NEW.id, 'name', NEW.name),
    (SELECT row_hash FROM audit ORDER BY id DESC LIMIT 1),
    encode(gen_random_bytes(16), 'hex')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION audit_insert_team() RETURNS trigger AS $$
BEGIN
  INSERT INTO audit (datetime, user_id, table_name, operation, new_value, prev_hash, row_hash)
  VALUES (
    CURRENT_TIMESTAMP,
    COALESCE(current_setting('app.user_id', true), '0')::int,
    'teams',
    'INSERT',
    json_build_object('id', NEW.id, 'league_id', NEW.league_id, 'user_id', NEW.user_id, 'name', NEW.name),
    (SELECT row_hash FROM audit ORDER BY id DESC LIMIT 1),
    encode(gen_random_bytes(16), 'hex')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION audit_insert_league() RETURNS trigger AS $$
BEGIN
  INSERT INTO audit (datetime, user_id, table_name, operation, new_value, prev_hash, row_hash)
  VALUES (
    CURRENT_TIMESTAMP,
    COALESCE(current_setting('app.user_id', true), '0')::int,
    'leagues',
    'INSERT',
    json_build_object('id', NEW.id, 'name', NEW.name, 'year', NEW.year, 'mlb_team', NEW.mlb_team),
    (SELECT row_hash FROM audit ORDER BY id DESC LIMIT 1),
    encode(gen_random_bytes(16), 'hex')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION audit_insert_stats() RETURNS trigger AS $$
BEGIN
  INSERT INTO audit (datetime, user_id, table_name, operation, new_value, prev_hash, row_hash)
  VALUES (
    CURRENT_TIMESTAMP,
    COALESCE(current_setting('app.user_id', true), '0')::int,
    'stats',
    'INSERT',
    json_build_object('id', NEW.id, 'player_id', NEW.player_id, 'team_id', NEW.team_id, 'date', NEW.date),
    (SELECT row_hash FROM audit ORDER BY id DESC LIMIT 1),
    encode(gen_random_bytes(16), 'hex')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION audit_insert_points() RETURNS trigger AS $$
BEGIN
  INSERT INTO audit (datetime, user_id, table_name, operation, new_value, prev_hash, row_hash)
  VALUES (
    CURRENT_TIMESTAMP,
    COALESCE(current_setting('app.user_id', true), '0')::int,
    'points',
    'INSERT',
    json_build_object('id', NEW.id, 'team_id', NEW.team_id, 'date', NEW.date, 'value', NEW.value, 'type', NEW.type),
    (SELECT row_hash FROM audit ORDER BY id DESC LIMIT 1),
    encode(gen_random_bytes(16), 'hex')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_players_ai ON players;
DROP TRIGGER IF EXISTS audit_teams_ai ON teams;
DROP TRIGGER IF EXISTS audit_leagues_ai ON leagues;
DROP TRIGGER IF EXISTS audit_stats_ai ON stats;
DROP TRIGGER IF EXISTS audit_points_ai ON points;

CREATE TRIGGER audit_players_ai
AFTER INSERT ON players
FOR EACH ROW EXECUTE FUNCTION audit_insert_player();

CREATE TRIGGER audit_teams_ai
AFTER INSERT ON teams
FOR EACH ROW EXECUTE FUNCTION audit_insert_team();

CREATE TRIGGER audit_leagues_ai
AFTER INSERT ON leagues
FOR EACH ROW EXECUTE FUNCTION audit_insert_league();

CREATE TRIGGER audit_stats_ai
AFTER INSERT ON stats
FOR EACH ROW EXECUTE FUNCTION audit_insert_stats();

CREATE TRIGGER audit_points_ai
AFTER INSERT ON points
FOR EACH ROW EXECUTE FUNCTION audit_insert_points();
"""


def main():
    if not os.getenv("DATABASE_URL"):
        raise SystemExit("DATABASE_URL is not set. This script initializes Postgres only.")

    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(SCHEMA_SQL)
            ensure_identities(
                conn,
                [
                    "leagues",
                    "users",
                    "user_accounts",
                    "teams",
                    "players",
                    "team_player",
                    "stats",
                    "points",
                    "roster_move_requests",
                    "roster_move_request_players",
                    "audit",
                ],
            )
            cur.execute(
                """
                TRUNCATE TABLE
                  team_player,
                  stats,
                  points,
                  roster_move_request_players,
                  roster_move_requests,
                  players,
                  teams,
                  users,
                  leagues,
                  audit
                RESTART IDENTITY CASCADE
                """
            )

    print("Postgres schema created.")

    roster_sync = load_module("roster_sync", "roster-sync.py")
    roster_sync.sync_phillies_40_man()

    with get_connection() as conn:
        make_league = load_module("make_test_league", "make-test-league.py")
        team_ids = make_league.make_test_league_and_teams(conn)
        make_league.assign_players_to_teams(conn, team_ids, force=True)
        conn.commit()

    stats_populate = load_module("stats_populate", "stats-populate.py")
    stats_populate.populate_2025_stats(start_date=None, end_date=None)
    score_weeks()

    print("Seeded roster, teams, stats, and scoring.")


if __name__ == "__main__":
    main()
